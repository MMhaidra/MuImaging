/* Cosmic-Ray Muon Imaging Program
 *
 * Class : MuEvent
 *
 * Author: Yitao Wu   2016/04/01
*/

/*************************************************************************
 * Copyright (C) 2014-2016, Yitao Wu, wu.topgun@gmail.com                *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see GPLv3.									 *
 *************************************************************************/

#ifndef YATO_MuEvent
#define YATO_MuEvent

#include "stdafx.h"

class MuEvent {

private:
		// Basic Info - Assigned by Constructor (Read only)
	_ID fEventID;			// Read only once object construct
	_P fMomentum;		// Momentum of muon
	_Point3 fHits[SYS::NUM_DETECTOR];		// Hits Array for all detectors
	double fYr;			// Scattering Param - with Momentum
		// PoCA Info - Generated by CalcPoCA (private function)
	_Angle fSAngle;			// Scattering angle (rad)
	_Point3* fPoCA;		// Point of the Closest Approaching
	_Point3* fPc;			// Point of the incidence crossing with common perpendicular
	_Point3* fQc;			// Point of the exit muon crossing with common perpendicular
		// Path Info (for TOF)
	_Len fLength[SYS::NUM_DETECTOR];
		// ML-EM Info - Generated by MuImage (class)
	TMatrixD* fData;			// Scattering Data - TMatrix(2,1){{angle},{dx}}
	TMatrixD* fDxz;
	TMatrixD* fDyz;
	TMatrixD* fCovar;		// Covariance Matrix - TMatrix(2,2)
	TMatrixD* fCovXZ;
	TMatrixD* fCovYZ;
	_IDList fVIDs;			// Voxel ID List that this event get through

public:
	MuEvent() ;
	MuEvent(_ID ev_id, _Point3 hits[], 
		_P ev_p = SYS::MOMENTUM_P0, int nHits = SYS::NUM_DETECTOR);
	virtual ~MuEvent();

	// Getter & Setter
	long GetEventID(){	return fEventID;}
	double GetMomentum() {	return fMomentum;}
	double GetSAngle() { return fSAngle;}
	bool GetHit(int index, _Point3* vTmp);
	bool GetPoCA( _Point3 *vTmp);
	bool GetPc( _Point3 *vTmp);
	bool GetQc( _Point3 *vTmp);
	bool GetData(TMatrixD& mTmp);
	bool GetDxz(TMatrixD& mTmp);
	bool GetDyz(TMatrixD& mTmp);
	_Len L(int index);
	_Len LOF();
	_IDList* GetVoxelList(){return &fVIDs;}
	void GetInverseCovar(TMatrixD& inSigma){inSigma = *fCovar;}
	void GetCovXZ(TMatrixD& sigma){sigma = *fCovXZ;}
	void GetCovYZ(TMatrixD& sigma){sigma = *fCovYZ;}
	double GetYr(){return fYr;}

	void SetLOF(_Len);
	void SetYr(double Kp){fYr=10*sqrt(Kp+1)/Kp;}
	void AddVoxel(_ID vid){fVIDs.push_back(vid);}
	void SetInverseCovar(TMatrixD& sigma){ *fCovar = sigma.Invert();}
	void SetCovXZ(TMatrixD& sigma){*fCovXZ = sigma.Invert();}
	void SetCovYZ(TMatrixD& sigma){*fCovYZ = sigma.Invert();}

	bool HasPoCA(){
		if(fPoCA) return true;
		return false;}
private:
	// Calculating the PoCA and scattering angle
	bool CalcPoCA();
};

inline bool MuEvent::GetHit(int index, _Point3* vTmp){
	if( fEventID == -1 || vTmp == NULL 
		|| index < 0 || index >= SYS::NUM_DETECTOR)
		return false;
	vTmp->SetXYZ(fHits[index].X(),fHits[index].Y(),fHits[index].Z());
	return true;
}//GetHit

inline bool MuEvent::GetPoCA( _Point3 *vTmp){
	if(fPoCA == NULL || vTmp == NULL)
		return false;
	vTmp->SetXYZ(fPoCA->X(), fPoCA->Y(), fPoCA->Z());
	return true;
}//GetPoCA

inline bool MuEvent::GetPc( _Point3 *vTmp){
	if(fPc == NULL || fPoCA == NULL || vTmp == NULL)
		return false;
	vTmp->SetXYZ(fPc->X(), fPc->Y(), fPc->Z());
	return true;
}//GetPc

inline bool MuEvent::GetQc( _Point3 *vTmp){
	if(fQc == NULL || fPoCA == NULL || vTmp == NULL)
		return false;
	vTmp->SetXYZ(fQc->X(), fQc->Y(), fQc->Z());
	return true;
}//GetPoCA

inline bool MuEvent::GetData(TMatrixD& mTmp){
	if(fData == NULL || mTmp.GetNrows() != 2 || mTmp.GetNcols() != 1 )
		return false;
	mTmp[0][0] = (*fData)[0][0];
	mTmp[1][0] = (*fData)[1][0];
	return true;
}//GetData

inline bool MuEvent::GetDxz(TMatrixD& mTmp){
	if(fDxz == NULL || mTmp.GetNrows() != 2 || mTmp.GetNcols() != 1 )
		return false;
	mTmp[0][0] = (*fDxz)[0][0];
	mTmp[1][0] = (*fDxz)[1][0];
	return true;
}//GetDxz

inline bool MuEvent::GetDyz(TMatrixD& mTmp){
	if(fDyz == NULL || mTmp.GetNrows() != 2 || mTmp.GetNcols() != 1 )
		return false;
	mTmp[0][0] = (*fDyz)[0][0];
	mTmp[1][0] = (*fDyz)[1][0];
	return true;
}//GetDxz

inline _Len MuEvent::L(int idx){
	if(idx < 0 || idx > SYS::NUM_DETECTOR){
		std::cout<<" !!!WARNNING!!! "
				<<"¡ª Invalid request for MuEvent::L "
				<<std::endl;
		return -1.;
	}
	return this->fLength[idx];
}
inline _Len MuEvent::LOF(){
	return this->fLength[1];
}
inline void MuEvent::SetLOF(_Len length){
	if(length < this->fLength[2]){
		std::cout<<" !!!WARNNING!!! "
				<<"¡ª Invalid value for MuEvent::SetLOF "
				<<std::endl;
		return;
	}
	this->fLength[2] = length;
}
#endif